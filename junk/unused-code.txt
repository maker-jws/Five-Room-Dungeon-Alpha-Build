
// console.log(doorLocations);
//     for(let m=1;m<=Object.keys(doorLocations).length;m++){
//        let mostCommon = doorLocations[0];
//        if (doorLocations[m][name]===mostCommon[name]){
//            const newMatch=doorLocation.slice(doorLocations[m])
//             mostCommon = doorLocations[m]
//     }
// } 
// function checkDoor(){
//     const name = 1;
//     const y = 2;
//     const x = 3;
//     const map = 4;
//     const doorA = doorLocations.slice();
    
//              //store the door "number" the player is in as 
// }
// }   
// return doorA;
// }

// for (let i=1;i<Object.keys(doorLocations).length+1;i++){ //search all doors in object
//     //supposed to store player information about door entered 'door A'
//     if(doorA[i][y]===player.y && doorA[i][x]===player.x && doorA[i][map]===player.map){ 
//         // if a door matches player y,x then change doorMatch to true;
        
//         console.log(doorA, 'door a after entering door.');
//         console.log(`You entered door ${doorLocations[i][name]}`);

// for (let m=1;m<Object.keys(doorLocations).length;m++){
//     const doorB = doorLocations[m].slice();
//      console.log(doorB, 'door b before check of map change');
//     if(player.direction === "up" && doorB[name] === doorA[name] && doorB[y] && doorA[map] !== doorB[map]){

//         player.populate(player.name,doorB[map],doorB[y],doorB[x])
       
//      } else if(player.direction === "down" && doorB[name] === doorA[name] && doorA[map] !== doorB[map]){
//         player.populate(player.name,doorB[map],doorB[y],doorB[x])
       
//      } else if(player.direction === "left" && doorB[name] === doorA[name] && doorA[map] !== doorB[map] ){
//         player.populate(player.name,doorB[map],doorB[y],doorB[x])
       
//      } if(player.direction === "right" && doorB[name] === doorA[name] && doorA[map] !== doorB[map]){
//         //if player direction is right AND  door b name is the same as door a name  AND doorB map is not the same as doorA map. 
//         player.populate(player.name,doorB[map],doorB[y],doorB[x])
        
        
//      }
// }   
// console.log(doorA,'a',doorB, 'b');
// doorA.length=0;
// doorB.length=0;
// console.log(doorA,'a',doorB, 'b');

const pathFinder = () => {
            // switch (this.x>=player.x){
            //     case (this.x>=player.x):
            //         this.direction = "right";
            //         this.move();
            //         // this.direction = "up";
            //         this.move();
            //     default: 
            //     // this.direction = path;
            //         this.direction = "right";
            //         this.move();
            //         // this.direction = "down";
            //         this.move();
            //     }
        }
        return pathFinder();

         // } if (this.y = player.y && this.x>player.x){
        //     this.direction = "left"
        //     this.move();
        //     this.direction = "left"
        //     this.move();
        // } else if (this.x = player.x && this.y<player.y){
        //     this.direction = "up"
        //     this.move();
        //     this.direction = "up"
        //     this.move();
        // } else if (this.y = player.y && this.x<player.x){
        //     this.direction = "right"
        //     this.move();
        //     this.direction = "right"
        //     this.move();
        // }
        // else if (this.x = player.x && this.y>player.y){
        //     this.direction = "down"
        //     this.move();
        //     this.direction = "down"
        //     this.move();
        // } 

            randomPath(){ 
        for (let i = choices.length - 1; i > 0; i--) {
            let r = Math.floor(Math.random() * (i + 1));
            let temp = choices[i];
            choices[i] = choices[r];
            choices[r] = temp;
        }
            const path = choices[choices.length-2]; //path random but if it read through options in order and returned path      
            this.direction = path;
            this.move()
            this.render();
    }